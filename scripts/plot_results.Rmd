---
title: "Plotting Results"
author: "Evan Gorstein"
date: "2023-07-30"
output:
  pdf_document: default
  html_document: default
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(patchwork)
library(RColorBrewer)
library(latex2exp)
library(kableExtra)
# set plotting theme -----------
theme_set(theme_bw())
theme_update(panel.grid = element_blank())

my_colors = brewer.pal(n=3, "Accent")[1:2]
scale_color_mine = function(...) {
  ggplot2:::manual_scale("color", 
               values = setNames(my_colors, c("lasso", "scad")),
               ...)
}

q.labs = c("q: 1", "q: 3", "q: 5")
names(q.labs) <- c("1", "3", "5")

p.labs = c("p=500", "p=1000")
names(p.labs) = c(500, 1000)

```



# Read in the data:
```{r, message=FALSE}
gene_results <- read_csv("../sim_results/best_results.csv")
gwas_results <- read_csv("../sim_results/gwas/best_results.csv")
otu_lr_results <- read_csv("../sim_results/OTU/LinShi/LinShi_lr_best_results.csv")
otu_results <- read_csv("../sim_results/OTU/spring/best_results.csv")
```

These data frames contain the fits with the best two BIC's (across all lambdas) for each dataset generated under each setting.


# Gene expression results
Let's check on the count for each setting

```{r}
gene_results %>%
  count(setting)
```

These numbers should all be 200. Unfortunately, they're not all 200 because for some settings not all 100 data sets receive top two results because some datasets failed to converge for all lambdas.

Looking at just the best lambda: 

```{r}
best_gene_results <- gene_results %>% 
  arrange(setting, data_id, bic) %>% 
  group_by(setting, data_id) %>%
  filter(row_number() == 1) %>%
  ungroup()

count(best_gene_results, setting)
```

These numbers should all be 100. 


Closer look to see what's missing

```{r}


bgr_filt <- best_gene_results %>%
  group_by(setting) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n < 100) %>%
  select(setting, data_id, lambda, n_nz, sigma, psi_1, bic) %>%
  arrange(setting, data_id) 
all <- expand(bgr_filt, setting, data_id)

#Missing
all %>% anti_join(bgr_filt)

#Present
bgr_filt %>% 
  right_join(all)

```


## Plotting gene results for nz = 5 

```{r}
bgr_nz5 <- best_gene_results %>%
  filter(str_detect(setting, "nz5")) %>%
  mutate(
    cor = str_extract(setting, "rho([0-9]+\\.[0-9]+)", group = 1),
    penalty = str_extract(setting, "covid_(.*)-", group = 1),
    p = as.numeric(
      str_extract(setting, "dim([0-9]+)", group = 1)
    ),
    predictor_cor = if_else(cor == "0.0", "No", "Yes"),
    fp = n_nz - tp,
    f = (2*tp)/(tp+fp+5)
  ) 
```

### False positive rate
In each of these boxplots, the data being plotted are the FPRs of a 100 models fit to 100 different simulated data sets. In particular, there is one model for each data set, the model that minimizes BIC.
```{r}
fp_nz5 <- bgr_nz5 %>% 
  group_by(penalty, p, predictor_cor) %>%
  mutate(outlier = fp > quantile(fp, .75) + IQR(fp) * 1.5) %>%
  ungroup() %>% 
  ggplot(aes(penalty, fp, col = penalty)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(data = function(x) dplyr::filter(x, outlier), pch=21, 
              height = 0, width = .3) +
  facet_grid(predictor_cor ~ p,
             labeller = labeller(.cols = label_both) ) +
  labs(y = "# false positives", x = "") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        #strip.text.x = element_text(size = 20),
        #strip.text.y = element_text(size = 10),
        text = element_text(size = 15),
        axis.text.y = element_text(size = 10)) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "Correlated features?", breaks = NULL, labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))

fp_nz5
ggsave(
    "../plots/fp_nz5.pdf",
    fp_nz5,
    width = 20,
    height = 15,
    units = "cm"
  )

```
```{r}
f_nz5 <- bgr_nz5 %>% 
  group_by(penalty, p, predictor_cor) %>%
  mutate(outlier = f > quantile(f, .75) + IQR(f) * 1.5 |
           f < quantile(f, .25) - IQR(f)*1.5) %>%
  ungroup() %>% 
  ggplot(aes(penalty, f, col = penalty)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(data = function(x) dplyr::filter(x, outlier), pch=21, 
              height = 0, width = .3) +
  facet_grid(predictor_cor ~ p,
             labeller = labeller(.cols = label_both) ) +
  labs(y = "F-score", x = "") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        #strip.text.x = element_text(size = 20),
        #strip.text.y = element_text(size = 10),
        text = element_text(size = 15),
        axis.text.y = element_text(size = 10)) +
  scale_y_continuous(sec.axis = sec_axis(~ . , name = "Correlated features?", breaks = NULL, labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))

f_nz5
ggsave(
    "../plots/f_nz5.pdf",
    fp_nz5,
    width = 20,
    height = 15,
    units = "cm"
  )

```




### True positives

```{r}

tp <- bgr_nz5 %>% 
  group_by(penalty, p, predictor_cor) %>%
  mutate(outlier = tp < quantile(tp, .75) + IQR(tp) * 1.5) %>%
  ungroup() %>%
  ggplot(aes(penalty, tp, col = penalty)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(data = function(x) dplyr::filter(x, outlier), pch=21,
              height = 0, width = .3) +
  facet_grid(predictor_cor ~ p,
             labeller = labeller(.cols = label_both) ) +
  labs(y = "# true positives (out of 5)", x = "") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        #strip.text.x = element_text(size = 20),
        #strip.text.y = element_text(size = 10),
        text = element_text(size = 15),
        axis.text.y = element_text(size = 10)) +
  scale_y_continuous(labels = scales::label_number(accuracy=1), limits = c(0,5),
                     sec.axis = sec_axis(~ . , name = "Correlated features?", breaks = NULL, labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))

tp

ggsave(
  "../plots/tp_nz5.pdf",
  tp,
  width = 20,
  height = 15,
  units = "cm"
)
```
All exactly 5! Perfect results

### Parameter estimates

How do we do at estimating the unpenalized intercept
```{r}
df_true <- data.frame(y_value = 1) 

unp <- bgr_nz5 %>% 
  group_by(penalty, p, predictor_cor) %>%
  mutate(outlier = beta_1 > quantile(beta_1, .75) + IQR(beta_1) * 1.5 | 
           beta_1 < quantile(beta_1, .25) - IQR(beta_1) * 1.5) %>%
  ungroup() %>% 
  ggplot(aes(penalty, beta_1, col = penalty)) +
  geom_boxplot(outlier.shape = 21) +
  # geom_jitter(data = function(x) dplyr::filter_(x, ~ outlier),
  #             height = 0, width = .3) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  facet_grid(predictor_cor ~ p,
             labeller = labeller(.cols = label_both) ) +
  labs(y = "Estimated intercept") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        #strip.text.x = element_text(size = 20),
        #strip.text.y = element_text(size = 10), 
        legend.title = element_blank(),
        text = element_text(size = 15), 
        axis.text.y = element_text(size = 10),
        legend.text = element_text(size = 10)) +
  scale_y_continuous(labels = scales::label_number(accuracy=.1), limits = c(.5,1.5),
                     sec.axis = sec_axis(~ . , 
                                         name = "Correlated features?", 
                                         breaks = NULL, 
                                         labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))

unp
ggsave(
  "../plots/unp_nz5.pdf",
  unp,
  width = 20,
  height = 15,
  units = "cm"
)
```

How do we do at estimating the penalized second component of beta?
```{r}
df_true <- data.frame(y_value = 2) 

penal <- bgr_nz5 %>%
  ggplot(aes(y = beta_2, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), outlier.shape=21) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  facet_grid(predictor_cor ~ p,
             labeller = labeller(.cols = label_both) ) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  facet_grid(predictor_cor ~ p,
             labeller = labeller(.cols = label_both) ) +
  labs(y = "Estimated parameter") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        #strip.text.x = element_text(size = 20),
        #strip.text.y = element_text(size = 10), 
        legend.title = element_blank(),
        text = element_text(size = 15), 
        axis.text.y = element_text(size = 10),
        legend.text = element_text(size = 10)) +
  scale_y_continuous(labels = scales::label_number(accuracy=.1), limits = c(1.5,2.5),
                     sec.axis = sec_axis(~ . , 
                                         name = "Correlated features?", 
                                         breaks = NULL, 
                                         labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))

penal
ggsave(
  "../plots/penal_nz5.pdf",
  penal,
  width = 20,
  height = 15,
  units = "cm"
)
```

LASSO is biased downward!

How do we do at estimating the variance component?
```{r}
df_true <- data.frame(y_value = .56) 

var_comp <- best_gene_results %>%
  filter(str_detect(setting, "nz5")) %>%
  mutate(
    cor = str_extract(setting, "rho([0-9]+\\.[0-9]+)", group = 1),
    penalty = str_extract(setting, "covid_(.*)-", group = 1),
    p = factor(
      str_extract(setting, "dim([0-9]+)", group = 1),
      levels = c('500', "1000")
    )
  ) %>% 
  mutate(`Correlated predictors` = if_else(cor == "0.0", "No", "Yes")) %>%
  ggplot(aes(y = psi_1, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), outlier.shape = 21) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  facet_grid(`Correlated predictors` ~ p) +
  labs(y = "Estimated parameter") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        #strip.text.x = element_text(size = 20),
        #strip.text.y = element_text(size = 10), 
        legend.title = element_blank(),
        text = element_text(size = 15), 
        axis.text.y = element_text(size = 10),
        legend.text = element_text(size = 10)) +
  scale_y_continuous(labels = scales::label_number(accuracy=.1),
                     sec.axis = 
                       sec_axis(~ . , name = "Correlated predictors?", 
                                breaks = NULL, labels = NULL)) +
  scale_x_continuous(sec.axis = 
                       sec_axis(~ . , name = "Fixed effect dimension", 
                                breaks = NULL, labels = NULL)) +
  scale_color_brewer(type = "qual", 
                     labels = c("LASSO", "SCAD"))
var_comp
ggsave(
  "../plots/var_comp_nz5.pdf",
  var_comp,
  width = 20,
  height = 15,
  units = "cm"
)
```
All estimates are biased downward.


## Plotting gene results for nz = 10



```{r}
bgr_nz10 = best_gene_results %>%
  filter(str_detect(setting, "nz10")) %>%
  mutate(
    cor = str_extract(setting, "rho([0-9]+\\.[0-9]+)", group = 1),
    penalty = factor(str_extract(setting, "cov.*_(.*)-", group = 1)),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = recode_factor(
      str_extract(setting, "cov(.*)_", group = 1),
      id = "scalar", diag = "diagonal", sym = "unstructured"
    ),
    predictor_cor = if_else(cor == "0.0", "No", "Yes"),
    fp = n_nz - tp,
    f = (2*tp)/(tp+fp+10)
  ) 



```

### False positive rate and F score

Summary of false positive results and F score
```{r}
bgr_nz10 %>%
  group_by(penalty, cov_str, q, predictor_cor) %>% 
  summarise(mn = mean(fp), min = min(fp), med = median(fp), max = max(fp), n = n())

bgr_nz10 %>%
  group_by(penalty, cov_str, q, predictor_cor) %>% 
  summarise(mn = mean(f), min = min(f), med = median(f), max = max(f), n = n())

```


```{r, warning=FALSE}
no_out = data.frame(q = c("1", "3", "3", "5"), 
                    cov_str = factor(
                      c("scalar", "unstructured", "unstructured", "scalar"), 
                      levels = c("scalar", "diagonal", "unstructured")
                      ),
                    penalty = c("lasso", "scad", "scad", "lasso"),
                    predictor_cor = c("No", "No", "Yes", "Yes"), 
                    fp = NA,
                    outlier = TRUE,
                    plot = FALSE)

fp_nz10 <- bgr_nz10 %>%
  group_by(penalty, cov_str, q, predictor_cor) %>%
  mutate(outlier = fp > quantile(fp, .75) + IQR(fp) * 1.5,
         plot = TRUE) %>%
  ungroup() %>% 
  bind_rows(no_out) %>%
  {
  ggplot(data =., aes(y = fp, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), outlier.shape = NA) +
  geom_point(data = filter(., outlier), 
             pch = 21, #aes(alpha = plot),
             position = position_jitterdodge(
               dodge.width = 0.9,
               jitter.height = 0,
               jitter.width = 0.2)) +
  labs(y = "# false positives", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(
    predictor_cor ~ q,
    scales = "free_x",
    space = "free",
    labeller = labeller(q = q.labs) 
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  guides(alpha = "none", color = "none") +
  theme(#strip.text.x = element_text(size = 10 ),
        #strip.text.y = element_text(size = 10),
        axis.ticks.x = element_blank(),
        text = element_text(size = 15), 
        axis.text.y = element_text(size = 10)) +
  scale_y_continuous(sec.axis = sec_axis(~ . , 
                                         name = "Correlated features?", 
                                         breaks = NULL, 
                                         labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))
}

fp_nz10

# Note that there are fewer than 100 data-sets for some of the lasso settings (but none of the scad settings)!
ggsave(
  "../plots/fp_nz10.pdf",
  fp_nz10,
  width = 20,
  height = 15,
  units = "cm"
) 


```

```{r, warning=FALSE}
no_out = data.frame(q = "5", 
                    cov_str = factor(
                      "scalar", 
                      levels = c("scalar", "diagonal", "unstructured")
                      ),
                    penalty = c("lasso"),
                    predictor_cor = c("Yes"), 
                    f = NA,
                    outlier = TRUE,
                    plot = FALSE)
f_nz10 <- bgr_nz10 %>%
  group_by(penalty, cov_str, q, predictor_cor) %>%
  mutate(outlier = f > quantile(f, .75) + IQR(f) * 1.5 |
           f < quantile(f, .25) - IQR(f)*1.5,
         plot = TRUE) %>%
  ungroup() %>%
  bind_rows(no_out) %>%
  {
  ggplot(data =., aes(y = f, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), outlier.shape = NA) +
  geom_point(data = filter(., outlier), 
             pch = 21, #aes(alpha = plot),
             position = position_jitterdodge(
               dodge.width = 0.9,
               jitter.height = 0,
               jitter.width = 0.2)) +
  labs(y = "F-score", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(
    predictor_cor ~ q,
    scales = "free_x",
    space = "free",
    labeller = labeller(q = q.labs) 
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  guides(alpha = "none", color = "none") +
  theme(#strip.text.x = element_text(size = 10 ),
        #strip.text.y = element_text(size = 10),
        axis.ticks.x = element_blank(),
        text = element_text(size = 15), 
        axis.text.y = element_text(size = 10)) +
  scale_y_continuous(sec.axis = sec_axis(~ . , 
                                         name = "Correlated features?", 
                                         breaks = NULL, 
                                         labels = NULL)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))
}

f_nz10

# Note that there are fewer than 100 data-sets for some of the lasso settings (but none of the scad settings)!
ggsave(
  "../plots/f_nz10.pdf",
  f_nz10,
  width = 20,
  height = 15,
  units = "cm"
) 
```





### True positives

```{r}
no_out = data.frame(q = c("1", "3", "3","3","3" ,"5", "5"), 
                    cov_str = factor(
                      c("scalar", "scalar", "scalar", "diagonal", "unstructured", "scalar", "scalar"), 
                      levels = c("scalar", "diagonal", "unstructured")
                      ),
                    penalty = c("scad", "scad", rep("lasso", 5)),
                    predictor_cor = c("No", "No", "Yes", "No", "No", "No", "Yes"), 
                    tp = NA,
                    outlier = TRUE,
                    plot = FALSE)

tp_nz10 <- bgr_nz10 %>%
  group_by(penalty, cov_str, q, predictor_cor) %>%
  mutate(outlier = tp > quantile(tp, .75) + IQR(tp) * 1.5 | tp < quantile(tp, .25) - IQR(tp)) %>%
  ungroup() %>% 
  bind_rows(no_out) %>%
  {
  ggplot(data = ., aes(y = tp, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), outlier.shape = NA)  +
  geom_point(data = filter(., outlier), 
             pch = 21, #aes(alpha = plot),
             position = position_jitterdodge(
               dodge.width = 0.9,
               jitter.height = 0,
               jitter.width = 0.3)) +
  labs(y = "# true positives (out of 10)", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(
    predictor_cor ~ q,
    scales = "free_x",
    space = "free",
    labeller = labeller(q = q.labs) 
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy=1),
                     sec.axis = sec_axis(~ . , 
                                         name = "Correlated features?", 
                                         breaks = NULL, 
                                         labels = NULL)) +
  guides(alpha = FALSE, color = FALSE) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual")
}

tp_nz10 
 
ggsave( 
  "../plots/tp_nz10.pdf",
  tp_nz10,
  width = 20,
  height = 15,
  units = "cm"
) 
```



### Parameter estimates

How do we do at estimating the unpenalized intercept
```{r}
df_true <- data.frame(y_value = 1) 

unp_nz10 <- bgr_nz10 %>%
  ggplot(aes(y = beta_1, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9))  +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  labs(y = "Estimated Intercept", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(
    predictor_cor ~ q,
    labeller = labeller(q = q.labs),
    scales = "free_x",
    space = "free"
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
    scale_y_continuous(labels = scales::label_number(accuracy=1), 
                       sec.axis = sec_axis(~ . , name = "Correlated predictors?", breaks = NULL, labels = NULL)) +
    theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.title = element_blank(),
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
    
unp_nz10
ggsave(
  "../plots/unp_nz10.pdf",
  unp_nz10,
  width = 20,
  height = 15,
  units = "cm"
)

```

```{r}
bgr_nz10 %>%
  filter(beta_8 != 0) %>%
  group_by(penalty, cov_str, q, predictor_cor) %>%
  summarise(mn = mean(beta_8), sd = sd(beta_8), n=n(), .groups = "drop") %>%
  filter(penalty == "scad") %>%
  select(q, cov_str, predictor_cor, n, mn, sd) %>%
  kbl(booktabs = T, 
      format = "latex", 
      digits=2,
      col.names = c("q", TeX("$\\Psi_\\theta$ structure"), "Correlated Features", "n", "Mean", "Standard deviation"))
```



```{r}

counts <- bgr_nz10 %>%
  filter(beta_8 != 0) %>%
  group_by(q, predictor_cor, cov_str, penalty) %>%
  summarise( n = n(), .groups = "drop")



df_true <- data.frame(y_value = -3) 

penal_nz10 <- bgr_nz10 %>%
  filter(beta_8 != 0) %>%
  ggplot(aes(y = beta_8, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9))  +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  labs(y = "Estimated Parameter", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(
    predictor_cor ~ q,
    labeller = labeller(q = q.labs),
    scales = "free_x",
    space = "free"
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  geom_text(data = counts, aes(cov_str, Inf, label = n), 
            position = position_dodge(width = 0.9), size = 5,
            vjust = 1.1) +
  scale_y_continuous(labels = scales::label_number(accuracy=1),
                       sec.axis = sec_axis(~ . , name = "Correlated features?", breaks = NULL, labels = NULL)) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10),
      legend.position = "none",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
    
penal_nz10
ggsave(
  "../plots/penal_nz10.pdf",
  penal_nz10,
  width = 20,
  height = 15,
  units = "cm"
)
```



Performance of the LASSO is affected negatively by correlation between predictors.

#### Scalar variance component

```{r}

df_true <- data.frame(y_value = 0.56) 

var_comp_nz10 <- bgr_nz10 %>%
  filter(cov_str == "scalar") %>%
  ggplot(aes(y = psi_1)) +
  geom_boxplot(position = position_dodge(width = 0.9), aes(col = penalty), outlier.shape = 21)  +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  labs(y = "Estimated parameter", x = TeX("Scalar \\Psi")) +
  facet_grid(
    predictor_cor ~ q,
    labeller = labeller(q = q.labs),
    scales = "free_x",
    space = "free"
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy=.1),
                       sec.axis = sec_axis(~ . , name = "Correlated features?", breaks = NULL, labels = NULL)) +
  coord_cartesian(ylim = c(0,1)) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      legend.position = "none",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
  
var_comp_nz10


ggsave(
  "../plots/var_comp_nz10.pdf",
  var_comp_nz10,
  width = 20,
  height = 15,
  units = "cm"
)
```


#### Diagonal variance components
```{r}
df_true <- data.frame(parameter = rep(c(1, 2, 3), 2), 
                      y_value = rep(c(3, 3, 2), 2), correlation = rep(c("No", "Yes"), each = 3))

var_diag_nz10 <- best_gene_results %>%
  filter(str_detect(setting, "nz10")) %>%
  mutate(
    correlation = str_extract(setting, "rho([0-9]+\\.[0-9]+)", group = 1),
    penalty = str_extract(setting, "cov.*_(.*)-", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = factor(
      str_extract(setting, "cov(.*)_", group = 1),
      levels = c("id", "diag", "sym")
    )) %>%
  mutate(correlation = if_else(correlation == "0.0", "No", "Yes")) %>%
  filter(q==3, cov_str == "diag") %>%
  pivot_longer(cols = c(psi_1, psi_5, psi_9), 
               names_to = "parameter", values_to = "estimate") %>%
  ggplot(aes(parameter, estimate)) +
  geom_boxplot(position = position_dodge(width = 0.9), aes(col = penalty), outlier.shape = 21) +
  geom_segment(data = df_true, aes(x = parameter-.4, xend = parameter+.4,
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  facet_grid(correlation ~ 1) +
  labs(y = "Estimated parameter", x = TeX("Diagonal $\\Psi")) +
  scale_y_continuous(labels = scales::label_number(accuracy=1), 
                       sec.axis = sec_axis(~ . , 
                                           name = "Correlated predictors?", 
                                           breaks = NULL, 
                                           labels = NULL)) +
  scale_x_discrete(labels = c( TeX("$\\Psi_{1,1}"), TeX("$\\Psi_{2,2}"), TeX("$\\Psi_{3,3}"))) +
  coord_cartesian(ylim = c(0,5)) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.position = "none",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10),
      strip.text.x = element_blank()) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
  
var_diag_nz10

ggsave(
  "../plots/var_diag_nz10.pdf",
  var_diag_nz10,
  width = 20,
  height = 15,
  units = "cm"
)
```




#### Symmetric variance components
```{r}
Lsym <- matrix(c(sqrt(3), 0 ,0, 1, sqrt(3), 0, -sqrt(2), 1, sqrt(2)), nrow = 3, byrow = T)
df_true <- data.frame(parameter = rep(1:9, 2), 
                      y_value = rep(as.vector(Lsym %*% t(Lsym)), 2), correlation = rep(c("No", "Yes"), each = 9))

var_sym_nz10 <- best_gene_results %>%
  filter(str_detect(setting, "nz10")) %>%
  mutate(
    correlation = str_extract(setting, "rho([0-9]+\\.[0-9]+)", group = 1),
    penalty = str_extract(setting, "cov.*_(.*)-", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = factor(
      str_extract(setting, "cov(.*)_", group = 1),
      levels = c("id", "diag", "sym")
    )) %>%
  mutate(correlation = if_else(correlation == "0.0", "No", "Yes")) %>%
  filter(q==3, cov_str == "sym") %>%
  pivot_longer(cols = paste0("psi_", 1:9), 
               names_to = "parameter", values_to = "estimate") %>%
  ggplot(aes(parameter, estimate)) +
  geom_boxplot(position = position_dodge(width = 0.9), aes(col = penalty), outlier.shape = 21) +
  geom_segment(data = df_true, aes(x = parameter-.4, xend = parameter+.4,
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  facet_grid(correlation ~ 1) +
  scale_x_discrete(labels = c( TeX("$\\Psi_{1,1}"),
                               TeX("$\\Psi_{1,2}"),
                               TeX("$\\Psi_{1,3}"),
                               TeX("$\\Psi_{2,1}"),
                               TeX("$\\Psi_{2,2}"),
                               TeX("$\\Psi_{2,3}"),
                               TeX("$\\Psi_{3,1}"),
                               TeX("$\\Psi_{3,2}"),
                               TeX("$\\Psi_{3,3}"))) +
  scale_y_continuous(labels = scales::label_number(accuracy=1), 
                       sec.axis = sec_axis(~ . , name = "Correlated predictors?", breaks = NULL, labels = NULL)) +
  labs(y = "Estimated parameter", x = TeX("Unstructured symmetric $\\Psi")) + 
  coord_cartesian(ylim = c(-5,6)) +
    theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.title = element_blank(),
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10),
      strip.text.x = element_blank()) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
 var_sym_nz10

ggsave(
  "../plots/var_sym_nz10.pdf",
  var_sym_nz10,
  width = 20,
  height = 15,
  units = "cm"
)

 
```
3 components of psi are identical to 3 others because symmetric


# GWAS Results

Check that there are 200 rows for each setting
```{r}
gwas_results %>%
  count(setting)
```

### False positive rate
```{r}
best_gwas_results <- gwas_results %>%
  group_by(setting, data_id) %>%
  arrange(bic, .by_group = TRUE) %>%
  filter(row_number() == 1) %>%
  mutate(
    penalty = str_extract(setting, "cov.*_(.*)-", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = recode_factor(
      str_extract(setting, "cov(.*)_", group = 1),
      id = "scalar", diag = "diagonal", sym = "unstructured"
    )
    )
```

```{r}

fp_gwas <- best_gwas_results  %>%
  group_by(cov_str, q) %>%
  mutate(fp = (n_nz - tp),
         outlier = fp > quantile(fp, .75) + IQR(fp) * 1.5,
         plot = TRUE) %>%
  ungroup() %>% {
  ggplot( data = ., aes(y = fp, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9),
               width = .3, outlier.shape = 21) +
  # geom_point(data = filter(., outlier), 
  #            pch = 21, #aes(alpha = plot),
  #            position = position_jitterdodge(
  #              dodge.width = 0.9,
  #              jitter.height = 0,
  #              jitter.width = 0.2)) +
  labs(y = "# False positives", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(. ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(breaks = c(0, 5,10,15,20, 40, 60), limits = c(0, NA), expand =  expansion(add = c(0, 1))) + 
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      axis.ticks.x = element_blank(),
      legend.title = element_blank(),
      legend.position = "top",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD"))
}
fp_gwas

ggsave(
    "../plots/fp_gwas.pdf",
    fp_gwas,
    width = 20,
    height = 15,
    units = "cm"
  )

```

False positive summary stats
```{r}
best_gwas_results %>%
  group_by(setting) %>%
  summarise(fp_mn = mean(n_nz-tp), 
            fp_min = min(n_nz-tp),
            fp_med = median(n_nz-tp),
            fp_max = max(n_nz-tp)
    )
```

### True positives
```{r}
counts <- best_gwas_results %>%
  group_by(penalty, cov_str, q) %>%
  summarise(
    cnt_perfect = sum(tp == 10), 
    ) 


tp_gwas <- best_gwas_results %>%
  mutate(
         outlier = tp < 10
         ) %>%
  filter(outlier) %>%
  ggplot(aes(y = tp, x = cov_str, col = penalty)) +
  geom_point(pch = 21, #aes(alpha = plot),
             position = position_jitterdodge(
               dodge.width = 0.9,
               jitter.height = .05,
               jitter.width = 0.3)) +
  geom_text(data = counts, aes(cov_str, 10, label = cnt_perfect),
            show.legend = FALSE,
            position = position_dodge(width = 0.9), size = 5) +
  labs(y = "# true positives (out of 10)", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(. ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy = 1), limits = c(0,10)) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.title = element_blank(),
      legend.position = "top",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", labels = c("LASSO", "SCAD")) 

tp_gwas

ggsave(
    "../plots/tp_gwas.pdf",
    tp_gwas,
    width = 20,
    height = 15,
    units = "cm"
  )
```
### Parameter estimates
How do we do at estimating the unpenalized intercept?
```{r}
df_true <- data.frame(y_value = 1) 


unp_gwas <- best_gwas_results %>%
  group_by(q, cov_str, penalty) %>%
  mutate(outlier = beta_1 > quantile(beta_1, .75) + IQR(beta_1) * 1.5 | 
           beta_1 < quantile(beta_1, .25) - IQR(beta_1) * 1.5) %>%
  ungroup() %>%
  ggplot(aes(y = beta_1, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), width = .3, outlier.shape = 21) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  labs(y = "Estimated intercept", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(~ q, labeller = "label_both",
             scales = "free", space = "free"
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy = 1)) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.title = element_blank(),
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", 
                     labels = c("LASSO", 
                                "SCAD"))

unp_gwas

ggsave(
    "../plots/unp_gwas.pdf",
    unp_gwas,
    width = 20,
    height = 15,
    units = "cm"
  )
```

How do we do estimating the penalized eighth component of beta?
```{r}
df_true <- data.frame(y_value = -3) 
penal_gwas <- best_gwas_results %>%
  group_by(q, cov_str, penalty) %>%
  mutate(outlier = beta_8 > quantile(beta_8, .75) + IQR(beta_8) * 1.5 | 
           beta_8 < quantile(beta_8, .25) - IQR(beta_8) * 1.5) %>%
  ungroup() %>%
  ggplot(aes(y = beta_8, x = cov_str, col = penalty)) +
  geom_boxplot(position = position_dodge(width = 0.9), width = .3, outlier.shape = 21) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter")) +
  labs(y = "Estimated penalized coefficient", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(~ q, labeller = "label_both",
             scales = "free", space = "free"
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy = 1)) +
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.position = "none",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", 
                     labels = c("LASSO", 
                                "SCAD"))

penal_gwas 

ggsave(
    "../plots/penal_gwas.pdf",
    penal_gwas,
    width = 20,
    height = 15,
    units = "cm"
  )
```
### Scalar variance components

```{r}
df_true1 <- data.frame(cov_str = c(1, 2, 3), y_value = c(.56, 3, 3), q = c(1, 3, 3)) 
df_true2 <- data.frame(cov_str = c(1, 2, 3), y_value = c(.56, 3, 3), q = c(3, 3, 3)) 
df_true3 <- data.frame(cov_str = c(1, 2, 3), y_value = c(.56, 3, 3), q = c(5, 3, 3))

var_comp_gwas <- best_gwas_results %>%
  mutate(
    penalty = str_extract(setting, "cov.*_(.*)-", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = factor(
      str_extract(setting, "cov(.*)_", group = 1),
      levels = c("id", "diag", "sym")
    )
  ) %>%
  ggplot(aes(y = psi_1, x = cov_str)) +
  geom_boxplot(aes(col = penalty),position = position_dodge(width = 0.9), width = .3) +
  geom_segment(data = df_true1, aes(x = cov_str-.4, xend = cov_str+.4, 
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  geom_segment(data = df_true2, aes(x = cov_str-.4, xend = cov_str+.4, 
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  geom_segment(data = df_true3, aes(x = cov_str-.4, xend = cov_str+.4, 
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  labs(y = "Estimated variance component", x = "Random effect covariance") +
  facet_grid(~ q, labeller = "label_both",
             scales = "free", space = "free"
  ) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.title = element_blank(),
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10)) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))

var_comp_gwas

ggsave(
    "../plots/var_comp_gwas.pdf",
    var_comp_gwas,
    width = 20,
    height = 15,
    units = "cm"
  )

```


### Diagonal variance components

If we want to check these, we must divide the elements of $\Psi$ by the variances of the corresponding columns of $Z$ because right now, they are on the scale of the standardized covariates (when we ran GWAS simulations, we had a previous version of the code that does not convert the random effects matrix back to the original scale).

As such, we have to read in the GWAS data matrices
```{r}
idxs = 1:100
diag_dfs <- idxs %>% map( 
                \(i) read_csv(paste0("../data/GWAS/random3_covdiag/data", i, ".csv"))
                )

variances <- diag_dfs %>% 
  map(\(df) tibble(x2_var = var(df$X2), x3_var = var(df$X3))) %>%
  list_rbind 
variances <- variances %>%
  mutate(data_id = paste0("data", row_number()))

```


```{r}
df_true <- data.frame(parameter = rep(c(1, 2, 3), 2), 
                      y_value = rep(c(3, 3, 2), 2), correlation = rep(c("No", "Yes"), each = 3))

var_diag_gwas <- best_gwas_results %>%
  mutate(
    penalty = str_extract(setting, "cov.*_(.*)-", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = factor(
      str_extract(setting, "cov(.*)_", group = 1),
      levels = c("id", "diag", "sym")
    )) %>%
  filter(q==3, cov_str == "diag") %>%
  left_join(variances, by = "data_id") %>%
  mutate(true_psi1 = psi_1, true_psi5 = psi_5/x2_var, true_psi9 = psi_9/x3_var) %>%
  pivot_longer(cols = c(true_psi1, true_psi5, true_psi9), 
               names_to = "parameter", values_to = "estimate") %>%
  ggplot(aes(parameter, estimate)) +
  geom_boxplot(position = position_dodge(width = 0.9), aes(col = penalty), outlier.shape = 21) +
  geom_segment(data = df_true, aes(x = parameter-.4, xend = parameter+.4,
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  labs(y = "Estimated parameter", x = TeX("Diagonal $\\Psi")) +
  scale_x_discrete(labels = c( TeX("$\\Psi_{1,1}"), TeX("$\\Psi_{2,2}"), TeX("$\\Psi_{3,3}"))) +

  theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.position = "none",
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10),
      strip.text.x = element_blank()) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
  
var_diag_gwas

ggsave(
  "../plots/var_diag_gwas.pdf",
  var_diag_gwas,
  width = 20,
  height = 15,
  units = "cm"
)
```
### Symmetric variance components

```{r}
idxs = 1:100
sym_dfs <- idxs %>% map( 
                \(i) read_csv(paste0("../data/GWAS/random3_covsym/data", i, ".csv"))
                )

sds <- sym_dfs %>% 
  map(\(df) tibble(x2_sd = sd(df$X2), x3_sd = sd(df$X3))) %>%
  list_rbind 
sds <- sds %>%
  mutate(data_id = paste0("data", row_number()))

```


```{r}

Lsym <- matrix(c(sqrt(3), 0 ,0, 1, sqrt(3), 0, -sqrt(2), 1, sqrt(2)), nrow = 3, byrow = T)
df_true <- data.frame(parameter = rep(1:9, 2), 
                      y_value = rep(as.vector(Lsym %*% t(Lsym)), 2))

var_sym_gwas <- best_gwas_results %>%
  mutate(
    penalty = str_extract(setting, "cov.*_(.*)-", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = factor(
      str_extract(setting, "cov(.*)_", group = 1),
      levels = c("id", "diag", "sym")
    )) %>%
  filter(q==3, cov_str == "sym") %>%
  left_join(sds, by = "data_id") %>%
  mutate(
    true_psi1 = psi_1, 
    true_psi2 = psi_2/x2_sd, 
    true_psi3 = psi_3/x3_sd,
    true_psi4 = psi_4/x2_sd,
    true_psi5 = psi_5/x2_sd^2,
    true_psi6 = psi_6/(x2_sd*x3_sd),
    true_psi7 = psi_7/x3_sd,
    true_psi8 = psi_8/(x2_sd*x3_sd),
    true_psi9 = psi_9/x3_sd^2
    ) %>%
  pivot_longer(cols = paste0("true_psi", 1:9), 
               names_to = "parameter", values_to = "estimate") %>%
  ggplot(aes(parameter, estimate)) +
  geom_boxplot(position = position_dodge(width = 0.9), aes(col = penalty), outlier.shape = 21) +
  geom_segment(data = df_true, aes(x = parameter-.4, xend = parameter+.4,
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  scale_x_discrete(labels = c( TeX("$\\Psi_{1,1}"),
                               TeX("$\\Psi_{1,2}"),
                               TeX("$\\Psi_{1,3}"),
                               TeX("$\\Psi_{2,1}"),
                               TeX("$\\Psi_{2,2}"),
                               TeX("$\\Psi_{2,3}"),
                               TeX("$\\Psi_{3,1}"),
                               TeX("$\\Psi_{3,2}"),
                               TeX("$\\Psi_{3,3}"))) +
  labs(y = "Estimated parameter", x = TeX("Unstructured symmetric $\\Psi")) + 
    theme(#strip.text.x = element_text(size = 10 ),
      #strip.text.y = element_text(size = 10), 
      legend.title = element_blank(),
      text = element_text(size = 13), 
      axis.text.y = element_text(size = 10),
      strip.text.x = element_blank()) +
  scale_color_brewer(type = "qual", 
                     labels = c("Estimates with LASSO", 
                                "Estimates with SCAD"))
var_sym_gwas

ggsave(
  "../plots/var_sym_gwas.pdf",
  var_sym_gwas,
  width = 20,
  height = 15,
  units = "cm"
)
```



# OTU Results

This cell takes super long to run because of the `case_when` function--I have no idea why...might want to change `case_when` to two nested if_elses
```{r}
best_otu_results <- otu_results %>%
  group_by(setting, data_id) %>%
  arrange(bic, .by_group = TRUE) %>%
  filter(row_number() == 1)  %>%
  mutate(
    penalty = str_extract(setting,  ".*_(.*)-", group = 1),
    correlation = str_extract(data_id, "_(.*)_", group = 1),
    q = str_extract(setting, "random([0-9])", group = 1),
    cov_str = recode_factor(
      str_extract(setting, "cov(.*)_", group = 1),
      id = "scalar", diag = "diagonal", sym = "unstructured"
    ),
    beta_ind2 = if_else(q == 1, beta_3, beta_2),
    beta_grp = if_else(q == 1, beta_2, if_else(q == 3, beta_4, beta_6))
  )

```

## False Positive rate

```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 

fp_otu <- best_otu_results %>%
  ggplot(aes(y = n_nz - tp, x = cov_str, col = penalty)) +
  geom_boxplot(width = .6, outlier.shape = 21) +
  labs(y = "# false positives", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(correlation ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(sec.axis =
                       sec_axis(~ .,
                                name = "OTU correlation structure",
                                breaks = NULL,
                                labels = NULL)
                     ) +
  theme(#strip.text.x = element_text(size = 10 ),
      legend.position = "none",
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.title.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates")

fp_otu

ggsave(
    "../plots/fp_otu.pdf",
    fp_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```
## True positives 

```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 

counts <- best_otu_results %>%
  group_by(correlation, cov_str, q, penalty) %>%
  summarise(
    cnt_perfect = sum(tp == 11), 
    ) 


tp_otu <- best_otu_results %>%
  mutate(
         outlier = tp < 11
         ) %>%
  filter(outlier) %>%
  ggplot(aes(y = tp, x = cov_str, col = penalty)) +
  geom_point(pch = 21, #aes(alpha = plot), 
             position = position_jitter(height = 0, width = .3)) +
  geom_text(data = counts, aes(cov_str, 11, label = cnt_perfect),
            show.legend = FALSE, size = 3.5) +
  labs(y = "# true positives (out of 11)", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(correlation ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy = 1),
                     breaks = c(4,6,11),
                     limits = c(0,12),
                     sec.axis =
                       sec_axis(~ .,
                                name = "OTU correlation structure",
                                breaks = NULL,
                                labels = NULL)
                     ) +
  theme(#strip.text.x = element_text(size = 10 ),
      legend.position = "none",
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates")

tp_otu

ggsave(
    "../plots/tp_otu.pdf",
    tp_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```


## Parameter estimates

How do we do at estimating the unpenalized intercept?
```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 
df_true <- data.frame(y_value = 1) 
unp_otu <- best_otu_results %>%
  ggplot(aes(y = beta_1, x = cov_str, col = penalty)) +
  geom_boxplot(outlier.size=0.1 ,width=.3) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter"),
             linewidth = .4) +
  labs(y = "Estimated Intercept", x = "Random effect covariance") +
  facet_grid(correlation ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(labels = scales::label_number(accuracy = 1),
                     sec.axis =
                       sec_axis(~ .,
                                name = "OTU correlation structure",
                                breaks = NULL,
                                labels = NULL)
                     ) +
  theme(#strip.text.x = element_text(size = 10 ),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates")

unp_otu

ggsave(
    "../plots/unp_otu.pdf",
    unp_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```




How do we do at estimating the penalized 7th component of beta? 
```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 
df_true <- data.frame(y_value = -1) 
pen_otu <- best_otu_results %>%
  ggplot(aes(y = beta_7, x = cov_str, col = penalty)) +
  geom_boxplot(outlier.size=0.1 ,width=.3) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter"),
             linewidth = .4) +
  labs(y = "Estimated parameter", x = "Random effect covariance") +
  facet_grid(correlation ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(breaks = seq(-1,0,.5)
                     ,sec.axis =
                       sec_axis(~ .,
                                name = "OTU correlation structure",
                                breaks = NULL,
                                labels = NULL)
                     ) +
 theme(#strip.text.x = element_text(size = 10 ),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates")

pen_otu

ggsave(
    "../plots/pen_otu.pdf",
    pen_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```

How do we do at estimating the second component of beta that is measured at the individual level. Note that this is beta3 for the settings with only 1 random effect and beta2 for the settings with more than 1 random effect. Also note that for the former, this coefficient is penalized, whereas it is not for the latter.



```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 
df_true <- data.frame(y_value = 2) 
beta_ind2_otu <- best_otu_results %>%
  ggplot(aes(y = beta_ind2, x = cov_str, col = penalty)) +
  geom_boxplot(outlier.size=0.1 ,width=.3) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter"),
             linewidth = .4) +
  labs(y = "Estimated parameter", x = "Random effect covariance") +
  facet_grid(. ~ q, space = "free", scales = "free_x",
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  # scale_y_continuous(sec.axis =
  #                      sec_axis(~ .,
  #                               name = "OTU correlation structure",
  #                               breaks = NULL,
  #                               labels = NULL)
  #                    ) +
 theme(#strip.text.x = element_text(size = 10 ),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = c("estimates")) 

beta_ind2_otu

ggsave(
    "../plots/beta_ind2_otu.pdf",
    beta_ind2_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```


How do we do at estimating the effect of the variable measured at the group level. Note that this is `beta_2` for settings with 1 random effect, `beta_4` for settings with 3 random effects, and `beta_6` for settings with 5 random effects. In all cases, the coefficient on this variable was unpenalized when we fit the model. 


```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 
df_true <- data.frame(y_value = -1) 
beta_grp_otu <- best_otu_results %>%  
  ggplot(aes(y = beta_grp, x = cov_str, col = penalty)) +
  geom_boxplot(outlier.size=0.1 ,width=.3) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter"),
             linewidth = .4) +
  labs(y = "Estimated parameter", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(correlation ~ q, space = "free", scales = "free", 
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(breaks = c(-2,-1,0),
                     sec.axis =
                      sec_axis(~ ., 
                               name = "OTU correlation structure",
                               breaks = NULL, 
                               labels = NULL)
                     ) +
  coord_cartesian(ylim = c(-2,0)) +
 theme(#strip.text.x = element_text(size = 10 ),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      legend.position = "top",
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates") 

beta_grp_otu

ggsave(
    "../plots/beta_grp_otu.pdf",
    beta_grp_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```

How do we do at estimating the intercept random effect variance

```{r}
# Change `.` to `correlation` in `facet_grid` and uncomment sec_axis 
# if you want break down by type of design matrix structure.
# Currently aggregating results across the OTU correlation structures 
df_true <- data.frame(y_value = .56) 
var_otu <- best_otu_results %>%
  ggplot(aes(y = psi_1, x = cov_str, col = penalty)) +
  geom_boxplot(outlier.size=0.1 ,width=.3) +
  geom_hline(data = df_true, aes(yintercept = y_value, linetype = "True Parameter"),
             linewidth = .4) +
  labs(y = "Estimated parameter", x = TeX("$\\Psi_\\theta$ structure")) +
  facet_grid(correlation ~ q, space = "free", scales = "free", 
             labeller = labeller(q = q.labs)) + #Get rid of space argument if you want box plot width to automatically adjust to space in facet
  scale_y_continuous(n.breaks = 3,
                     sec.axis =
                       sec_axis(~ ., name = "OTU correlation structure",
                        breaks = NULL,
                        labels = NULL)
                     ) +
  coord_cartesian(ylim = c(0,1)) +
  theme(#strip.text.x = element_text(size = 10 ),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      legend.position = "top",
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates") 
  

var_otu

ggsave(
    "../plots/var_otu.pdf",
    var_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```


#### Diagonal variance components

```{r}

df_true <- data.frame(parameter = rep(c(1, 2, 3), 6), 
                      y_value = rep(c(.56, 1, 1), 6), 
                      correlation = rep(levels(factor(best_otu_results$correlation)), each = 3))

var_diag_otu <- best_otu_results %>%
  filter(q==3, cov_str == "diagonal") %>%
  pivot_longer(cols = c(psi_1, psi_5, psi_9), 
               names_to = "parameter", values_to = "estimate") %>%
  ggplot(aes(parameter, estimate)) +
  geom_boxplot(outlier.shape = 21 , width = .5, aes(col = penalty)) +
  geom_segment(data = df_true, aes(x = parameter-.25, xend = parameter+.25,
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  facet_grid(correlation ~ 1) +
  scale_y_continuous(limits = c(0,2), 
                     n.breaks = 3,
                     sec.axis=
                       sec_axis(~ ., name = "Design matrix structure",
                        breaks = NULL,
                        labels = NULL)
                      ) +
 theme(strip.text.x = element_blank(),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.text.y = element_text(size = 10)) +
  scale_color_mine(label = "estimates")


var_diag_otu


ggsave(
    "../plots/var_diag_otu.pdf",
    beta_grp_otu,
    width = 20,
    height = 15,
    units = "cm"
  )


```
### Symmetric variance components

```{r}
Lsym <- matrix(c(sqrt(.56), 0,0, sqrt(.5), sqrt(.5), 0, sqrt(.1), -sqrt(.8), sqrt(.1)), nrow = 3, byrow=T)
df_true <- data.frame(parameter = rep(1:6, 6), 
                      y_value = rep(miscTools::vecli(Lsym %*% t(Lsym)), 6), correlation = rep(levels(factor(best_otu_results$correlation)), each = 6))


var_sym_otu <- best_otu_results %>%
  filter(q==3, cov_str == "unstructured") %>%
  pivot_longer(cols = c(psi_1, psi_2, psi_3, psi_5, psi_6, psi_9), 
               names_to = "parameter", values_to = "estimate") %>%
  ggplot(aes(parameter, estimate)) +
  geom_boxplot(outlier.size=0.1 ,width=.3, aes(col = penalty)) +
  geom_segment(data = df_true, aes(x = parameter-.4, xend = parameter+.4,
                                   y = y_value, yend = y_value,
                                   linetype = "True Parameter")) +
  facet_grid(. ~ 1) +
  scale_y_continuous(limits = c(-2,2), 
                     n.breaks = 5,
                     # sec.axis=
                     #   sec_axis(~ ., name = "Design matrix structure",
                     #    breaks = NULL,
                     #    labels = NULL)
                      ) +
 theme(strip.text.x = element_blank(),
      strip.text.y = element_text(size = 6), 
      legend.title = element_blank(),
      axis.text.y = element_text(size = 10)) +
  scale_color_mine()

var_sym_otu

ggsave(
    "../plots/var_sym_otu.pdf",
    beta_grp_otu,
    width = 20,
    height = 15,
    units = "cm"
  )
```














